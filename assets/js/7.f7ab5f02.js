(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{171:function(t,e,_){"use strict";_.r(e);var s=_(0),i=Object(s.a)({},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),_("p",[t._v("一般情况下都是CSS在头部，JS在底部。")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),_("p",[t._v("先贴地址"),_("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651555392&idx=1&sn=9042c990f82fe5d03f03e6af7536b4c3&chksm=80255181b752d897524a6f1ee332f245761c89a5e01d0cbf0499e3a74a21f3865f8cfff823cf&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("从URL输入到页面展现到底发生什么"),_("OutboundLink")],1),t._v("\n有点详细，可以慢慢看")]),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),_("hr"),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"optimised"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#optimised","aria-hidden":"true"}},[this._v("#")]),this._v(" optimised")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"一-网站优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-网站优化","aria-hidden":"true"}},[this._v("#")]),this._v(" 一 网站优化")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("p",[this._v("1 减少 HTTP 请求数量\n在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（不同浏览器允许并发数），一旦 HTTP 请求数量达到一定数量，资源请求就存在等待状态，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。")])]),this._v(" "),e("li",[e("p",[this._v("2 控制资源文件加载优先级\n浏览器在加载HTML内容时，是将HTML内容从上至下依次解析，解析到link或者script标签就会加载href或者src对应链接内容，为了第一时间展示页面给用户，就需要将CSS提前加载，不要受 JS 加载影响。")])])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("3 利用浏览器缓存\n浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。")])]),t._v(" "),_("li",[_("p",[t._v("4 减少重排（Reflow）\n基本原理：重排是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的visibility属性，这也是Reflow低效的原因。如果Reflow的过于频繁，CPU使用率就会急剧上升。")]),t._v(" "),_("p",[t._v("减少Reflow，如果需要在DOM操作时添加样式，尽量使用 增加class属性，而不是通过style操作样式。")])]),t._v(" "),_("li",[_("p",[t._v("5 减少 DOM 操作")])]),t._v(" "),_("li",[_("p",[t._v("6 图标使用 IconFont 替换")])]),t._v(" "),_("li",[_("p",[t._v("7")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"二-面试必考-从url输入到页面展现到底发生什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-面试必考-从url输入到页面展现到底发生什么","aria-hidden":"true"}},[this._v("#")]),this._v(" 二 面试必考-从URL输入到页面展现到底发生什么")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("1 解析域名")]),this._v(" "),e("li",[this._v("2 HTTP请求阶段：TCP三次握手，http请求相应信息，关闭TCP连接")]),this._v(" "),e("li",[this._v("3 服务器处理请求饼返回HTTP报文")]),this._v(" "),e("li",[this._v("4 浏览器拿到响应文本HTML后，解析渲染页面（这个得具体说一下：1 根据HTML解析出DOM树 ；2 根据CSS解析生成CSS规则树 ； 3 结合DOM树和CSS规则树，生成render树 ； 4 根据render树计算每一个节点的信息 ； 5 根据计算好的信息绘制页面 ； 6 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上）")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("多线程的浏览器内核： GUI渲染线程/JS引擎线程/事件触发线程/定时器线程/网络请求线程===>所以才说JS是单线程的啊")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"三-来谈谈网络请求相关的东西"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-来谈谈网络请求相关的东西","aria-hidden":"true"}},[this._v("#")]),this._v(" 三 来谈谈网络请求相关的东西")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("p",[t._v("1 三次握手/四次挥手")]),t._v(" "),_("p",[t._v("客户端：hello，你是server么？")]),t._v(" "),_("p",[t._v("服务端：hello，我是server，你是client么")]),t._v(" "),_("p",[t._v("客户端：yes，我是client")]),t._v(" "),_("p",[t._v("建立连接成功后，开始正式传输数据。然后，待到断开连接时，进行四次挥手：")]),t._v(" "),_("p",[t._v("主动方：我已经关闭了向你那边的主动通道了，只能被动接收了")]),t._v(" "),_("p",[t._v("被动方：收到通道关闭的信息")]),t._v(" "),_("p",[t._v("被动方：那我也告诉你，我这边向你的主动通道也关闭了")]),t._v(" "),_("p",[t._v("主动方：最后收到数据，之后双方无法通信")])]),t._v(" "),_("li",[_("p",[t._v("2 get和post的区别")]),t._v(" "),_("p",[t._v("get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。get会产生一个tcp数据包，post两个。\n具体就是：")]),t._v(" "),_("p",[t._v("get请求时，浏览器会把 headers和 data一起发送出去，服务器响应200（返回数据），")]),t._v(" "),_("p",[t._v("post请求时，浏览器先发送 headers，服务器响应 100continue，浏览器再发送 data，服务器响应200（返回数据）。")]),t._v(" "),_("p",[t._v("再说一点，这里的区别是 specification（规范）层面，而不是 implementation（对规范的实现）")])]),t._v(" "),_("li",[_("p",[t._v("3 HTTPS")]),t._v(" "),_("p",[t._v("https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。")]),t._v(" "),_("p",[t._v("简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析")]),t._v(" "),_("p",[t._v("一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）")])]),t._v(" "),_("li",[_("p",[t._v("4 强缓存与弱缓存")]),t._v(" "),_("p",[t._v("强缓存（ 200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求")]),t._v(" "),_("p",[t._v("协商缓存（ 304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存")])]),t._v(" "),_("li",[_("p",[t._v("5 渲染过程")]),t._v(" "),_("p",[t._v("外链资源的下载：单独开启一个下载线程去下载资源；")]),t._v(" "),_("p",[t._v("css资源的处理：异步下载，不会阻塞构建DOM树，但会阻塞渲染（主要是渲染之后可能需要重新绘制），media query声明的css是不会阻塞渲染的")]),t._v(" "),_("p",[t._v("js脚本：会阻塞浏览器的解析，必须等JS下载并执行后才会继续解析HTML。现代浏览器会优化此过程，但JS脚本可以并行下载，但解析仍是阻塞的 defer和async会使JS脚本在解析完毕后再执行")]),t._v(" "),_("p",[t._v("img图片：异步下载，不会阻塞，下载完毕后直接用图片替换原有的src的地方")]),t._v(" "),_("hr")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"四-js模块化编程之commonjs-amd-cmd"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四-js模块化编程之commonjs-amd-cmd","aria-hidden":"true"}},[this._v("#")]),this._v(" 四 JS模块化编程之CommonJS,AMD,CMD")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("1 CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}\n"),_("ul",[_("li",[t._v("require()用来引入外部模块；")]),t._v(" "),_("li",[t._v("exports对象用于导出当前模块的方法或变量，唯一的导出口；")]),t._v(" "),_("li",[t._v("module对象就代表模块本身。")])])]),t._v(" "),_("li",[t._v('2 基于commonJS规范的nodeJS出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。但是，由于浏览器端的模块，不能采用"同步加载"（synchronous），只能采用"异步加载"（asynchronous），使得CommonJS规范不适用于浏览器环境。')])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("blockquote",[e("blockquote",[e("p",[this._v('AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：require([module], callback);第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。')])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("3 大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些.最大的区别：SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行")])])}],!1,null,null,null);e.default=i.exports}}]);