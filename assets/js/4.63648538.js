(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{171:function(s,e,a){"use strict";a.r(e);var t=a(0),n=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"前端基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端基础","aria-hidden":"true"}},[s._v("#")]),s._v(" 前端基础")]),s._v(" "),a("h3",{attrs:{id:"一-数据持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一-数据持久化","aria-hidden":"true"}},[s._v("#")]),s._v(" 一 数据持久化")]),s._v(" "),a("h3",{attrs:{id:"二-function传值属于值传递"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-function传值属于值传递","aria-hidden":"true"}},[s._v("#")]),s._v(" 二 function传值属于值传递")]),s._v(" "),a("ul",[a("li",[s._v("值类型，当为函数传递参数的时候，是将此值复制一份传递给函数，所以在函数执行之后，num本身的值并没有被改变，函数中被改变的值仅仅是一个副本而已。例如"),a("code",[s._v("string")]),s._v("，12")]),s._v(" "),a("li",[s._v("引用类型，当为函数传递参数的时候，是传递的web对象的引用，也就是此对象的内存地址，所以在函数中修改属性的对象就是函数外面创建的对象本身。")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('function setName(obj)\n{ \n  obj.name="青岛新锐"; \n  obj=new Object(); \n  obj.name="蚂蚁部落"; \n} \nvar web=new Object(); \nsetName(web); \nconsole.log(web.name);\n\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("以上代码的弹出值是:青岛新锐，很多人可能会以为将会弹出“蚂蚁部落”，下面进行一下简单的分析:\n在函数外面创建一个对象，并将对象的引用赋值给变量web，web中存储的是对象在内存中的存储地址，当为函数传递参数时，就是传递的在函数外面创建的对象的地址。在函数中，为外面创建的对象创建一个自定义属性name并赋值为“青岛新锐”，然后又创建一个新的对象，并将新对象的地址赋值给obj，这个时候obj指向的并不是函数外面创建的对象，所以外面对象name属性不会被改变。简单地说，就是传入的参数是一个引用的副本，通过这个副本引用，我们可以访问到外部的对象，但是在我们手动将引用地址修改后，函数内访问的是另一个对象，而不是外部的对象。")]),s._v(" "),a("h3",{attrs:{id:"三-bind-apply-call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-bind-apply-call","aria-hidden":"true"}},[s._v("#")]),s._v(" 三 bind,apply,call")]),s._v(" "),a("h3",{attrs:{id:"四-深究scoped模块私有化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四-深究scoped模块私有化","aria-hidden":"true"}},[s._v("#")]),s._v(" 四 深究scoped模块私有化")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("scoped 主要作用再于：当一个style标签有scoped属性时，由它定义的css样式只能作用于当前的vue组件，可以使组件的样式不互相污染。")])]),s._v(" "),a("li",[a("p",[s._v("实现原理：通过postcss为转译后的dom添加唯一的动态属性，css编译为对应的属性选择器，这样就使的当前的样式只作用于含有该属性的dom元素。")])]),s._v(" "),a("li",[a("p",[s._v("如何对子组件进行scoped穿透：")]),s._v(" "),a("blockquote",[a("p",[s._v("在stylus中：使用 >>> 例如：.warpper>>>.swiper-pagination")])]),s._v(" "),a("blockquote",[a("p",[s._v("在sass和less中，使用/deep/ 例如：.warpper /deep/ .swiper-pagination")])])]),s._v(" "),a("li",[a("p",[s._v("在组件中修改第三方组件库样式的其他方法：使用两个style标签，一个使用scoped，一个不使用，6不6 ，就是这么简单...")])])])])}],!1,null,null,null);e.default=n.exports}}]);