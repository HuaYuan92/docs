(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{170:function(t,i,e){"use strict";e.r(i);var s=e(0),l=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,i=t.$createElement,e=t._self._c||i;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"optimised"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#optimised","aria-hidden":"true"}},[t._v("#")]),t._v(" optimised")]),t._v(" "),e("h3",{attrs:{id:"一-网站优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-网站优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 一 网站优化")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("1 减少 HTTP 请求数量\n在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（不同浏览器允许并发数），一旦 HTTP 请求数量达到一定数量，资源请求就存在等待状态，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。")])]),t._v(" "),e("li",[e("p",[t._v("2 控制资源文件加载优先级\n浏览器在加载HTML内容时，是将HTML内容从上至下依次解析，解析到link或者script标签就会加载href或者src对应链接内容，为了第一时间展示页面给用户，就需要将CSS提前加载，不要受 JS 加载影响。")])])]),t._v(" "),e("p",[t._v("一般情况下都是CSS在头部，JS在底部。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("3 利用浏览器缓存\n浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。")])]),t._v(" "),e("li",[e("p",[t._v("4 减少重排（Reflow）\n基本原理：重排是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的visibility属性，这也是Reflow低效的原因。如果Reflow的过于频繁，CPU使用率就会急剧上升。")])])]),t._v(" "),e("p",[t._v("减少Reflow，如果需要在DOM操作时添加样式，尽量使用 增加class属性，而不是通过style操作样式。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("5 减少 DOM 操作")])]),t._v(" "),e("li",[e("p",[t._v("6 图标使用 IconFont 替换")])]),t._v(" "),e("li",[e("p",[t._v("7")])])])])}],!1,null,null,null);i.default=l.exports}}]);