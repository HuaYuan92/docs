<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>optimised | 日积月累</title>
    <meta name="description" content="技术积累">
    <link rel="icon" href="/docs/favicon.ico">
    
    <link rel="preload" href="/docs/assets/css/0.styles.861fb22f.css" as="style"><link rel="preload" href="/docs/assets/js/app.35a33fa3.js" as="script"><link rel="preload" href="/docs/assets/js/7.649f4e6f.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.e6a4b27a.js"><link rel="prefetch" href="/docs/assets/js/11.28002d60.js"><link rel="prefetch" href="/docs/assets/js/2.12651511.js"><link rel="prefetch" href="/docs/assets/js/3.e65a0ec3.js"><link rel="prefetch" href="/docs/assets/js/4.de1c6a20.js"><link rel="prefetch" href="/docs/assets/js/5.bd154785.js"><link rel="prefetch" href="/docs/assets/js/6.d539d3f9.js"><link rel="prefetch" href="/docs/assets/js/8.594c196e.js"><link rel="prefetch" href="/docs/assets/js/9.e3069a10.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.861fb22f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">日积月累</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/HuaYuan92/docs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/HuaYuan92/docs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/docs/vue/base.html" class="sidebar-link">前端基础</a></li><li><a href="/docs/vue/vue.html" class="sidebar-link">Vue</a></li><li><a href="/docs/vue/optimised.html" class="active sidebar-link">optimised</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/vue/optimised.html#optimised" class="sidebar-link">optimised</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/vue/optimised.html#一-网站优化" class="sidebar-link">一 网站优化</a></li><li class="sidebar-sub-header"><a href="/docs/vue/optimised.html#二-面试必考-从url输入到页面展现到底发生什么" class="sidebar-link">二 面试必考-从URL输入到页面展现到底发生什么</a></li><li class="sidebar-sub-header"><a href="/docs/vue/optimised.html#三-来谈谈网络请求相关的东西" class="sidebar-link">三 来谈谈网络请求相关的东西</a></li><li class="sidebar-sub-header"><a href="/docs/vue/optimised.html#四-js模块化编程之commonjs-amd-cmd" class="sidebar-link">四 JS模块化编程之CommonJS,AMD,CMD</a></li></ul></li></ul></li><li><a href="/docs/vue/bugs.html" class="sidebar-link">bug-list</a></li><li><a href="/docs/vue/website.html" class="sidebar-link">后台和数据库</a></li><li><a href="/docs/vue/data.html" class="sidebar-link">算法与数据结构</a></li></ul> </div> <div class="page"> <div class="content"><h2 id="optimised"><a href="#optimised" aria-hidden="true" class="header-anchor">#</a> optimised</h2> <h3 id="一-网站优化"><a href="#一-网站优化" aria-hidden="true" class="header-anchor">#</a> 一 网站优化</h3> <ul><li><p>1 减少 HTTP 请求数量
在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（不同浏览器允许并发数），一旦 HTTP 请求数量达到一定数量，资源请求就存在等待状态，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。</p></li> <li><p>2 控制资源文件加载优先级
浏览器在加载HTML内容时，是将HTML内容从上至下依次解析，解析到link或者script标签就会加载href或者src对应链接内容，为了第一时间展示页面给用户，就需要将CSS提前加载，不要受 JS 加载影响。</p></li></ul> <p>一般情况下都是CSS在头部，JS在底部。</p> <ul><li><p>3 利用浏览器缓存
浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。</p></li> <li><p>4 减少重排（Reflow）
基本原理：重排是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的visibility属性，这也是Reflow低效的原因。如果Reflow的过于频繁，CPU使用率就会急剧上升。</p> <p>减少Reflow，如果需要在DOM操作时添加样式，尽量使用 增加class属性，而不是通过style操作样式。</p></li> <li><p>5 减少 DOM 操作</p></li> <li><p>6 图标使用 IconFont 替换</p></li> <li><p>7</p></li></ul> <h3 id="二-面试必考-从url输入到页面展现到底发生什么"><a href="#二-面试必考-从url输入到页面展现到底发生什么" aria-hidden="true" class="header-anchor">#</a> 二 面试必考-从URL输入到页面展现到底发生什么</h3> <p>先贴地址<a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651555392&idx=1&sn=9042c990f82fe5d03f03e6af7536b4c3&chksm=80255181b752d897524a6f1ee332f245761c89a5e01d0cbf0499e3a74a21f3865f8cfff823cf&scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">从URL输入到页面展现到底发生什么<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>
有点详细，可以慢慢看</p> <ul><li>1 解析域名</li> <li>2 HTTP请求阶段：TCP三次握手，http请求相应信息，关闭TCP连接</li> <li>3 服务器处理请求饼返回HTTP报文</li> <li>4 浏览器拿到响应文本HTML后，解析渲染页面（这个得具体说一下：1 根据HTML解析出DOM树 ；2 根据CSS解析生成CSS规则树 ； 3 结合DOM树和CSS规则树，生成render树 ； 4 根据render树计算每一个节点的信息 ； 5 根据计算好的信息绘制页面 ； 6 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上）</li></ul> <blockquote><p>多线程的浏览器内核： GUI渲染线程/JS引擎线程/事件触发线程/定时器线程/网络请求线程===&gt;所以才说JS是单线程的啊</p></blockquote> <hr> <h3 id="三-来谈谈网络请求相关的东西"><a href="#三-来谈谈网络请求相关的东西" aria-hidden="true" class="header-anchor">#</a> 三 来谈谈网络请求相关的东西</h3> <ul><li><p>1 三次握手/四次挥手</p> <p>客户端：hello，你是server么？</p> <p>服务端：hello，我是server，你是client么</p> <p>客户端：yes，我是client</p> <p>建立连接成功后，开始正式传输数据。然后，待到断开连接时，进行四次挥手：</p> <p>主动方：我已经关闭了向你那边的主动通道了，只能被动接收了</p> <p>被动方：收到通道关闭的信息</p> <p>被动方：那我也告诉你，我这边向你的主动通道也关闭了</p> <p>主动方：最后收到数据，之后双方无法通信</p></li> <li><p>2 get和post的区别</p> <p>get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。get会产生一个tcp数据包，post两个。
具体就是：</p> <p>get请求时，浏览器会把 headers和 data一起发送出去，服务器响应200（返回数据），</p> <p>post请求时，浏览器先发送 headers，服务器响应 100continue，浏览器再发送 data，服务器响应200（返回数据）。</p> <p>再说一点，这里的区别是 specification（规范）层面，而不是 implementation（对规范的实现）</p></li> <li><p>3 HTTPS</p> <p>https就是安全版本的http，譬如一些支付等操作基本都是基于https的，因为http请求的安全系数太低了。</p> <p>简单来看，https与http的区别就是： 在请求前，会建立ssl链接，确保接下来的通信都是加密的，无法被轻易截取分析</p> <p>一般来说，如果要将网站升级成https，需要后端支持（后端需要申请证书等），然后https的开销也比http要大（因为需要额外建立安全链接以及加密等），所以一般来说http2.0配合https的体验更佳（因为http2.0更快了）
2xx 以 2 开头的表示请求正常处理完毕
200 OK，表示从客户端发来的请求在服务器端被正常处理了</p> <p>3xx 表示需要进行附加操作以完成请求（重定向）
301 Moved Permanently ，永久性重定向，该状态表示请求的资源已被分配了新的 URI
指的是永久性的移动
302 Found ，临时重定向，表示请求的资源已被分配新的 URI ,但是暂时性的</p> <p>4xx 表示服务器无法处理请求
400 Bad Request 该状态码表示请求的报文存在语法错误，需要修改内容再次发送请求。
401 Unauthorized，该状态码表示发送的请求需要通过 HTTP 认证的认证信息，例外若需要之前进行过一次请求，则表示用户认证失败
403 ForBidden ，表示对请求的资源的访问被服务器拒绝了
404 Not Found ，无法找到请求的资源，也可以表示服务端拒绝请求且不想说明的理由。</p> <p>5xx 服务器请求出错
500 Internal Server Error ，服务器内部出现了错误
503 Service Unavailable ，表明服务器正处于超负荷或者正在进行停机维护，无法处理请求。</p></li> <li><p>4 强缓存与弱缓存</p> <p>强缓存（ 200 from cache）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起http请求</p> <p>协商缓存（ 304）时，浏览器会向服务端发起http请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存</p></li> <li><p>5 渲染过程</p> <p>外链资源的下载：单独开启一个下载线程去下载资源；</p> <p>css资源的处理：异步下载，不会阻塞构建DOM树，但会阻塞渲染（主要是渲染之后可能需要重新绘制），media query声明的css是不会阻塞渲染的</p> <p>js脚本：会阻塞浏览器的解析，必须等JS下载并执行后才会继续解析HTML。现代浏览器会优化此过程，但JS脚本可以并行下载，但解析仍是阻塞的 defer和async会使JS脚本在解析完毕后再执行</p> <p>img图片：异步下载，不会阻塞，下载完毕后直接用图片替换原有的src的地方</p></li> <li><p>6 http1.1的缺陷</p> <p>高延迟--带来页面加载速度的降低/无状态特性--带来的巨大HTTP头部/明文传输--带来的不安全性/不支持服务器推送消息：虽然近几年来网络带宽增长非常快，然而我们却并没有看到网络延迟有对应程度的降低。网络延迟问题主要由于队头阻塞(Head-Of-Line Blocking),导致带宽无法被充分利用。</p> <p>队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。针对队头阻塞,人们尝试过以下办法来解决:</p> <p>1、将同一页面的资源分散到不同域名下，提升连接上限。 Chrome有个机制，对于同一个域名，默认允许同时建立 6 个 TCP持久连接，使用持久连接时，虽然能公用一个TCP管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。另外如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。2、Spriting合并多张小图为一张大图,再用JavaScript或者CSS将小图重新“切割”出来的技术。3、内联(Inlining)是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。4、拼接(Concatenation)将多个体积较小的JavaScript使用webpack等工具打包成1个体积更大的JavaScript文件,但如果其中1个文件的改动就会导致大量数据被重新下载多个文件。</p></li> <li><p>7 HTTP/2 ：HTTP/2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）。从目前的情况来看，国内外一些排名靠前的站点基本都实现了HTTP/2的部署，使用HTTP/2能带来20%~60%的效率提升。新特性：HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩 ； 缺陷： TCP 以及 TCP+TLS建立连接的延时/TCP的队头阻塞并没有彻底解决。</p></li> <li><p>8 HTTP/3 ： Google 在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而这个“HTTP over QUIC”就是HTTP协议的下一个大版本，HTTP/3。它在HTTP/2的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。</p> <hr></li></ul> <h3 id="四-js模块化编程之commonjs-amd-cmd"><a href="#四-js模块化编程之commonjs-amd-cmd" aria-hidden="true" class="header-anchor">#</a> 四 JS模块化编程之CommonJS,AMD,CMD</h3> <ul><li>1 CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}
<ul><li>require()用来引入外部模块；</li> <li>exports对象用于导出当前模块的方法或变量，唯一的导出口；</li> <li>module对象就代表模块本身。</li></ul></li> <li>2 基于commonJS规范的nodeJS出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。但是，由于浏览器端的模块，不能采用&quot;同步加载&quot;（synchronous），只能采用&quot;异步加载&quot;（asynchronous），使得CommonJS规范不适用于浏览器环境。</li></ul> <blockquote><blockquote><blockquote><p>AMD是&quot;Asynchronous Module Definition&quot;的缩写，意思就是&quot;异步模块定义&quot;。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：require([module], callback);第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。</p></blockquote></blockquote></blockquote> <ul><li>3 大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些.最大的区别：SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行</li></ul></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">10/18/2019, 4:46:09 PM</span></div></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/docs/vue/vue.html" class="prev">
          Vue
        </a></span> <span class="next"><a href="/docs/vue/bugs.html">
          bug-list
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/docs/assets/js/app.35a33fa3.js" defer></script><script src="/docs/assets/js/7.649f4e6f.js" defer></script>
  </body>
</html>
