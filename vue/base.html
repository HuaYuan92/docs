<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端基础 | 日积月累</title>
    <meta name="description" content="技术积累">
    <link rel="icon" href="/docs/favicon.ico">
    
    <link rel="preload" href="/docs/assets/css/0.styles.861fb22f.css" as="style"><link rel="preload" href="/docs/assets/js/app.8ea3efe7.js" as="script"><link rel="preload" href="/docs/assets/js/5.b7d813dc.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.e5eaf26e.js"><link rel="prefetch" href="/docs/assets/js/11.7657a4a0.js"><link rel="prefetch" href="/docs/assets/js/12.bb6c7eae.js"><link rel="prefetch" href="/docs/assets/js/13.4cbe9aee.js"><link rel="prefetch" href="/docs/assets/js/2.071f4b9a.js"><link rel="prefetch" href="/docs/assets/js/3.54fdeefe.js"><link rel="prefetch" href="/docs/assets/js/4.b287dde8.js"><link rel="prefetch" href="/docs/assets/js/6.be484924.js"><link rel="prefetch" href="/docs/assets/js/7.2e3a1ba4.js"><link rel="prefetch" href="/docs/assets/js/8.9a6a1a94.js"><link rel="prefetch" href="/docs/assets/js/9.b036d295.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.861fb22f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">日积月累</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/HuaYuan92/docs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">GitHub</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/HuaYuan92/docs" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub地址
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/docs/vue/base.html" class="active sidebar-link">前端基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/vue/base.html#前端基础" class="sidebar-link">前端基础</a></li><li class="sidebar-sub-header"><a href="/docs/vue/base.html#一-数据持久化" class="sidebar-link">一 数据持久化</a></li><li class="sidebar-sub-header"><a href="/docs/vue/base.html#二-function传值属于值传递" class="sidebar-link">二 function传值属于值传递</a></li><li class="sidebar-sub-header"><a href="/docs/vue/base.html#三-bind-apply-call和this的关系" class="sidebar-link">三 bind,apply,call和this的关系</a></li><li class="sidebar-sub-header"><a href="/docs/vue/base.html#四-深究scoped模块私有化" class="sidebar-link">四 深究scoped模块私有化</a></li><li class="sidebar-sub-header"><a href="/docs/vue/base.html#五-发布自己的npm包" class="sidebar-link">五 发布自己的NPM包</a></li><li class="sidebar-sub-header"><a href="/docs/vue/base.html#六-将1-2版本的elementui升级到最新版本的尝试" class="sidebar-link">六 将1.2版本的elementUI升级到最新版本的尝试</a></li><li class="sidebar-sub-header"><a href="/docs/vue/base.html#七-restful" class="sidebar-link">七 restful</a></li><li class="sidebar-sub-header"><a href="/docs/vue/base.html#八-chrome打开一个页面需要启动多少进程？分别是哪些进程？" class="sidebar-link">八 Chrome打开一个页面需要启动多少进程？分别是哪些进程？</a></li><li class="sidebar-sub-header"><a href="/docs/vue/base.html#九-promise" class="sidebar-link">九 Promise</a></li><li class="sidebar-sub-header"><a href="/docs/vue/base.html#十-js事件队列" class="sidebar-link">十 JS事件队列</a></li><li class="sidebar-sub-header"><a href="/docs/vue/base.html#十一-hybrid-app-h5与原生的交互原理" class="sidebar-link">十一 Hybrid App H5与原生的交互原理</a></li></ul></li><li><a href="/docs/vue/vue.html" class="sidebar-link">Vue</a></li><li><a href="/docs/vue/optimised.html" class="sidebar-link">optimised</a></li><li><a href="/docs/vue/bugs.html" class="sidebar-link">bug-list</a></li><li><a href="/docs/vue/website.html" class="sidebar-link">后台和数据库</a></li><li><a href="/docs/vue/data.html" class="sidebar-link">算法与数据结构</a></li></ul> </div> <div class="page"> <div class="content"><h2 id="前端基础"><a href="#前端基础" aria-hidden="true" class="header-anchor">#</a> 前端基础</h2> <h2 id="一-数据持久化"><a href="#一-数据持久化" aria-hidden="true" class="header-anchor">#</a> 一 数据持久化</h2> <ul><li>cookie 生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。</li> <li>localStorage 生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。</li> <li>sessionStorage 为每一个数据源维持一个存储区域，在浏览器打开期间存在，包括页面重新加载。不同的浏览器存储的上限也不一样，但大多数浏览器把上限限制在5MB以下。</li></ul> <h2 id="二-function传值属于值传递"><a href="#二-function传值属于值传递" aria-hidden="true" class="header-anchor">#</a> 二 function传值属于值传递</h2> <ul><li>值类型，当为函数传递参数的时候，是将此值复制一份传递给函数，所以在函数执行之后，num本身的值并没有被改变，函数中被改变的值仅仅是一个副本而已。例如<code>string</code>，12</li> <li>引用类型，当为函数传递参数的时候，是传递的web对象的引用，也就是此对象的内存地址，所以在函数中修改属性的对象就是函数外面创建的对象本身。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>function setName(obj)
{ 
  obj.name=&quot;青岛新锐&quot;; 
  obj=new Object(); 
  obj.name=&quot;蚂蚁部落&quot;; 
} 
var web=new Object(); 
setName(web); 
console.log(web.name);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>以上代码的弹出值是:青岛新锐，很多人可能会以为将会弹出“蚂蚁部落”，下面进行一下简单的分析:
在函数外面创建一个对象，并将对象的引用赋值给变量web，web中存储的是对象在内存中的存储地址，当为函数传递参数时，就是传递的在函数外面创建的对象的地址。在函数中，为外面创建的对象创建一个自定义属性name并赋值为“青岛新锐”，然后又创建一个新的对象，并将新对象的地址赋值给obj，这个时候obj指向的并不是函数外面创建的对象，所以外面对象name属性不会被改变。简单地说，就是传入的参数是一个引用的副本，通过这个副本引用，我们可以访问到外部的对象，但是在我们手动将引用地址修改后，函数内访问的是另一个对象，而不是外部的对象。</p> <blockquote><p>重点就是我们传入的是一个值引用的副本！！！</p></blockquote> <h2 id="三-bind-apply-call和this的关系"><a href="#三-bind-apply-call和this的关系" aria-hidden="true" class="header-anchor">#</a> 三 bind,apply,call和this的关系</h2> <p>其实三个方法实际上的作用都是改变函数运行时this的指向，所以我要先来理一理this的指向问题。就我的理解而言，实际上ES6之后很少关注this的指向问题了。</p> <ul><li>方法调用模式：this指向当前对象。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>let a =1;
let obj={
a:2,
fn:function(){
console.log(this.a)
}
}
obj.fn()
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>普通函数调用：此时this被绑定到window上</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>function fn1(){
    console.log(this)//window;
}
//包括函数嵌套也是一样
function fn1(){
    function fn2(){
        console.log(this)//window
    }
}
// 把函数赋值之后再调用
let a =1;
let obj = {
    a:2,
    fn:function(){
        console.log(this.a)
    }
}
let fn1=obj.fn;
fn1()//1
fn1()调用实际上就是不带任何修饰的函数调用，相当于function(){ console.log(this.a) }.call(undefined),对于传入的context是null或者undefined,那么window对象就是默认的context（严格模式下默认 context 是 undefined）。因此上面的this绑定的就是window，这也被称为隐形绑定。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ul><li>构造器调用：new一个函数时，背地里会将创建一个连接到prototype成员的新对象，同时this会被绑定到那个新对象上</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>   function Person(name='name',age=18){
       //this都指向创建的实例
       this.name=name;
       this.age=age;
       this.sayAge=function(){
           console.log(this.age)
       }
   }
   let dot =new Person('Dot',2);
   dot.sayAge() //2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li>call call方法的第一个参数是要绑定给this的值，后面传入的是一个参数列表。当第一个参数为null，undefined的时候，默认指向window。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>let obj = {
    message: 'My name is: '
}
function getName(firstName, lastName) {
    console.log(this.message + firstName + ' ' + lastName)
}
getName.call(obj, 'Dot', 'Dolby')
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>apply apply接受两个参数，第一个参数是要绑定给this的值，第二个参数是一个参数数组。当第一个参数为null、undefined的时候，默认指向window。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>let obj = {
    message: 'My name is: '
}
function getName(firstName, lastName) {
    console.log(this.message + firstName + ' ' + lastName)
}
getName.apply(obj, ['Dot', 'Dolby'])// My name is: Dot Dolby
可以看到，obj 是作为函数上下文的对象，函数 getName 中 this 指向了 obj 这个对象。参数 firstName 和 lastName 是放在数组中传入 getName 函数。
事实上apply 和 call 的用法几乎相同, 唯一的差别在于：当函数需要传递多个变量时, apply 可以接受一个数组作为参数输入, call 则是接受一系列的单独变量。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>bind 和call很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。区别在于bind方法返回值是函数以及bind接收的参数列表的使用。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>let obj = {
    name: 'Dot'
}
function printName() {
    console.log(this.name)
}
let dot = printName.bind(obj)
console.log(dot) // function () { … }
dot()  // Dot
bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 printName 中的 this 并没有被改变，依旧指向全局对象 window。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="四-深究scoped模块私有化"><a href="#四-深究scoped模块私有化" aria-hidden="true" class="header-anchor">#</a> 四 深究scoped模块私有化</h2> <ul><li><p>scoped 主要作用再于：当一个style标签有scoped属性时，由它定义的css样式只能作用于当前的vue组件，可以使组件的样式不互相污染。</p></li> <li><p>实现原理：通过postcss为转译后的dom添加唯一的动态属性，css编译为对应的属性选择器，这样就使的当前的样式只作用于含有该属性的dom元素。</p></li> <li><p>如何对子组件进行scoped穿透：</p> <blockquote><p>在stylus中：使用 &gt;&gt;&gt; 例如：.warpper&gt;&gt;&gt;.swiper-pagination</p></blockquote> <blockquote><p>在sass和less中，使用/deep/ 例如：.warpper /deep/ .swiper-pagination</p></blockquote></li> <li><p>在组件中修改第三方组件库样式的其他方法：使用两个style标签，一个使用scoped，一个不使用，6不6 ，就是这么简单...</p></li></ul> <h2 id="五-发布自己的npm包"><a href="#五-发布自己的npm包" aria-hidden="true" class="header-anchor">#</a> 五 发布自己的NPM包</h2> <ul><li>npm adduser 添加用户</li> <li>npm publish 发布NPM包，完事...</li></ul> <h2 id="六-将1-2版本的elementui升级到最新版本的尝试"><a href="#六-将1-2版本的elementui升级到最新版本的尝试" aria-hidden="true" class="header-anchor">#</a> 六 将1.2版本的elementUI升级到最新版本的尝试</h2> <ul><li>克隆elementUI最新版</li> <li>改名，将elementUI改名为axx-element-ui</li> <li>发布axx-element-ui npm包</li> <li>在项目中引入axx-element-ui，修改.babelrc文件</li> <li>引入成功
BUT：由于element最新版依赖的vue版本跟现有版本不同，所以有些UI组件的功能并不能使用，比如$attr这个API在vue2.4以后才能使用；尝试升级vue版本，各种报错，当前项目太大太老，要单独升级某个依赖并不可能，个人感觉只有全局依赖一起升级这条路，升级的话，还需要改原有的业务代码，实际上相当于重写当前项目，工作量还是蛮大的，暂时搁浅。</li></ul> <h2 id="七-restful"><a href="#七-restful" aria-hidden="true" class="header-anchor">#</a> 七 restful</h2> <ul><li><p>用URL定位资源，用HTTP描述操作：
在设计web接口的时候，REST主要是用于定义接口名，接口名一般是用名次写，不用动词，那怎么表达“获取”或者“删除”或者“更新”这样的操作呢——用请求类型来区分。比如，我们有一个friends接口，对于“朋友”我们有增删改查四种操作，怎么定义REST接口？</p> <p>1、增加一个朋友，uri: generalcode.cn/v1/friends 接口类型：POST</p> <p>2、删除一个朋友，uri: generalcode.cn/va/friends 接口类型：DELETE</p> <p>3、修改一个朋友，uri: generalcode.cn/va/friends 接口类型：PUT</p> <p>4、查找朋友，uri: generalcode.cn/va/friends 接口类型：GET</p> <p>上面我们定义的四个接口就是符合REST协议的，请注意，这几个接口都没有动词，只有名词friends，都是通过Http请求的接口类型来判断是什么业务操作。
举个反例：generalcode.cn/va/deleteFriends 该接口用来表示删除朋友，这就是不符合REST协议的接口。</p> <p>用HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误，403表示Bad Request等。（反例：传统web开发返回的状态码一律都是200，其实不可取。）</p> <p>那这种风格的接口有什么好处呢？前后端分离。前端拿到数据只负责展示和渲染，不对数据做任何处理。后端处理数据并以JSON格式传输出去，定义这样一套统一的接口，在web，ios，android三端都可以用相同的接口，是不是很爽？！</p></li></ul> <h2 id="八-chrome打开一个页面需要启动多少进程？分别是哪些进程？"><a href="#八-chrome打开一个页面需要启动多少进程？分别是哪些进程？" aria-hidden="true" class="header-anchor">#</a> 八 Chrome打开一个页面需要启动多少进程？分别是哪些进程？</h2> <ul><li><p>打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。</p></li> <li><p>浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</p></li> <li><p>渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</p></li> <li><p>GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</p></li> <li><p>网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</p></li> <li><p>插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</p></li></ul> <h2 id="九-promise"><a href="#九-promise" aria-hidden="true" class="header-anchor">#</a> 九 Promise</h2> <h2 id="十-js事件队列"><a href="#十-js事件队列" aria-hidden="true" class="header-anchor">#</a> 十 JS事件队列</h2> <ul><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）</li> <li>等待任务的回调结果进入一种任务队列(task queue)。</li> <li>当主执行栈中的同步任务执行完毕后才会读取任务队列，任务队列中的异步任务（即之前等待任务的回调结果）会塞入主执行栈，</li> <li>异步任务执行完毕后会再次进入下一个循环。</li></ul> <p>在实际情况中，上述的任务队列(task queue)中的异步任务分为两种：微任务（micro task)和宏任务（macro task)。</p> <ul><li>micro task事件：Promises(浏览器实现的原生Promise)、MutationObserver、process.nextTick</li> <li>macro task事件：setTimeout、setInterval、setImmediate、I/O、UI rendering</li> <li>这里注意：script(整体代码)即一开始在主执行栈中的同步代码本质上也属于macrotask，属于第一个执行的task</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>microtask和macotask执行规则：
 *  macrotask按顺序执行，浏览器的ui绘制会插在每个macrotask之间；
 *  microtask按顺序执行，会在如下情况下执行：
    * 每个callback之后，只要没有其他的JS在主执行栈中；
    * 每个macrotask结束时

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="十一-hybrid-app-h5与原生的交互原理"><a href="#十一-hybrid-app-h5与原生的交互原理" aria-hidden="true" class="header-anchor">#</a> 十一 Hybrid App H5与原生的交互原理</h2> <ul><li><p>单向通信</p> <p>1、不需要传参的通信，如页面跳转；
2、需要传参的通信：URL传参/window传参</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>因为 app 是宿主，可以直接访问 h5，所以这种调用比较简单，就是在 h5 中曝露一些全局对象（包括方法），然后在原生 app中调用这些对象。
H5：
window.sdk={
 double = value =&gt; value * 2
}

IOS
NSString *func = @&quot;window.sdk.double(10)&quot;;
NSString *str = [webview stringByEvaluatingJavaScriptFromString:func];// 20

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>双向通信</p> <p>上面说的单向通信的交互通常会使一个简单的方法变得非常割裂，在一些稍微复杂的场景之下，双端的维护成本很高，因此通常我们使用双向通信的时候更多一些。我们可以在回调函数中做很多事情。这里就要提到大家耳熟能详的<a href="https://www.cnblogs.com/dailc/p/5931324.html" target="_blank" rel="noopener noreferrer">WebViewJavaScriptBridge<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>WebViewJavaScriptBridge的基本原理简单来说就是，建立一个桥梁，然后注册自己，调用他人。</p> <p>H5触发url scheme-&gt;Native捕获url scheme-&gt;原生分析,执行-&gt;原生调用h5</p> <ul><li><p>把 OC 的方法注册到桥梁中，让 JS 去调用。</p></li> <li><p>把 JS 的方法注册在桥梁中，让 OC 去调用。</p></li></ul></li></ul></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">9/21/2020, 4:33:42 PM</span></div></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/docs/vue/vue.html">
          Vue
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/docs/assets/js/app.8ea3efe7.js" defer></script><script src="/docs/assets/js/5.b7d813dc.js" defer></script>
  </body>
</html>
